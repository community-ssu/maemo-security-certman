// ------------------------------------------------------------------------
/// \file c_farray
/// \brief The c_farray template
//
// Revision $Id: c_farray,v 1.6 2005/02/15 10:54:09 p3kauppi Exp $
//
// ------------------------------------------------------------------------
// (C) Copyright Nokia 2004
// ------------------------------------------------------------------------

#ifndef c_farray_def
#define c_farray_def

/// \class c_farray
/// \ingroup lowleveltools
/// \brief A flexible pointer-array template
///
/// A template for a flexible pointer array, that grows
/// automatically when new data is added to it

template <class T>
class c_farray
{
 public:
  /// \brief Constructor

  c_farray ();

  /// \brief Destructor

  ~c_farray ();

  /// \brief Add new data to the array
  /// \param data A pointer to the value to be stored
  /// \returns The index of the new value
  /// 
  /// Note! Only the pointer is stored and no copy 
  /// is made of the data. If you store a dynamically
  /// allocated value or a pointer to the stack, and
  /// the actual value is discarded, bad things are
  /// bound to happen. The array takes care of deleting
  /// the stored values when it is reset or deleted.

  int add_value (T* data);

  /// \brief Insert an element to the array
  /// \param pos Insert position, starting from 0
  /// \param data A pointer to the value to be inserted

  void insert_value(int pos, T* data);

  /// \brief How many elements there are in the array
  /// \return The number of elements

  int nbrof_values ();

  /// \brief Return a value from the given position
  /// \return A pointer to 

  T* value (int at_pos);

  /// \brief Remove a value in the given position
  ///
  /// The destructor of the discarded value is called

  void remove_value(int at_pos);

  /// \brief Remove all values

  void reset();

 private:
  T** values;
  int arr_size;
  int elem_count;
};


// The implementation
#include <malloc.h>

template <class T>
c_farray<T> :: c_farray ()
{
  values = NULL;
  arr_size = 0;
  elem_count = 0;
}


template <class T>
c_farray<T> :: ~c_farray ()
{
  if (elem_count > 0)
    for (int i = 0; i < elem_count; i++)
      delete (values[i]);
  free (values);
  values = NULL;
  arr_size = 0;
  elem_count = 0;
}


template <class T>
int c_farray<T> :: add_value (T* data)
{
  T** swap;
  int new_size;

  new_size = elem_count + 1;
  if (new_size >= arr_size) {

    // Need to enlargen the array. Increase the allocation linearly
    // in 10 cell steps
    if (arr_size == 0)
      arr_size = 10;

    while (arr_size < new_size)
      arr_size += 10;

    swap = (T**) malloc(arr_size * sizeof(T*));
    if (values) {
      memcpy(swap, values, elem_count * sizeof(T*));
      free(values);
    };
    values = swap;
  };
  values[elem_count] = data;
  elem_count++;
  return elem_count - 1;
}


template <class T>
void c_farray<T> :: insert_value (int pos, T* data)
{
  if (pos < 0)
    return;

  int npos = add_value(data);
  if (pos >= 0 && pos < npos) {
    T* swap = values[npos];
    for (int i = npos; i > pos; i--)
      values[i] = values[i - 1];
    values[pos] = swap;
  };
}


template <class T>
int c_farray<T> :: nbrof_values ()
{
  return elem_count;
}


template <class T>
T* c_farray<T> :: value(int at_pos)
{
  if (at_pos >= 0 && at_pos < elem_count)
    return values[at_pos];
  else
    return NULL;
}


template <class T>
void c_farray<T> :: remove_value (int at_pos)
{
  if (at_pos >= 0 && at_pos < elem_count) {
    delete (values[at_pos]);
    elem_count--;
    for (int i = at_pos; i < elem_count; i++)
      values[i] = values[i + 1];
    values[elem_count] = NULL;
  };
}


template <class T>
void c_farray<T> :: reset ()
{
  for (int i = elem_count; i > 0; i--)
    remove_value(i - 1);
  elem_count = 0;
}
#endif
